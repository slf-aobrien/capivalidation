// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BenefitDTOReq BenefitDTOReq
//
// swagger:model BenefitDTOReq
type BenefitDTOReq struct {

	// administration type
	AdministrationType string `json:"administrationType,omitempty"`

	// alias
	Alias string `json:"alias,omitempty"`

	// benefit amount
	BenefitAmount string `json:"benefitAmount,omitempty"`

	// benefit determination type
	BenefitDeterminationType string `json:"benefitDeterminationType,omitempty"`

	// benefit feature
	BenefitFeature *BenefitFeatureDTO `json:"benefitFeature,omitempty"`

	// benefit flavor
	BenefitFlavor string `json:"benefitFlavor,omitempty"`

	// benefit tranch list
	BenefitTranchList []*BenefitTranchDTO `json:"benefitTranchList"`

	// benefit type
	BenefitType string `json:"benefitType,omitempty"`

	// care coverage type
	CareCoverageType string `json:"careCoverageType,omitempty"`

	// census class
	CensusClass string `json:"censusClass,omitempty"`

	// cert face page code
	CertFacePageCode string `json:"certFacePageCode,omitempty"`

	// coverage grouping
	CoverageGrouping *CoverageGroupingDTO `json:"coverageGrouping,omitempty"`

	// coverage statement code
	CoverageStatementCode string `json:"coverageStatementCode,omitempty"`

	// dental series
	DentalSeries string `json:"dentalSeries,omitempty"`

	// dental type
	DentalType string `json:"dentalType,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// effective date
	EffectiveDate string `json:"effectiveDate,omitempty"`

	// elected amount
	ElectedAmount string `json:"electedAmount,omitempty"`

	// eligibility rule
	EligibilityRule *EligibilityRuleDTOReq `json:"eligibilityRule,omitempty"`

	// event date
	EventDate string `json:"eventDate,omitempty"`

	// event reasons code
	EventReasonsCode string `json:"eventReasonsCode,omitempty"`

	// expire date
	ExpireDate string `json:"expireDate,omitempty"`

	// funding type
	FundingType string `json:"fundingType,omitempty"`

	// future effective
	FutureEffective bool `json:"futureEffective,omitempty"`

	// gi free cover
	GiFreeCover string `json:"giFreeCover,omitempty"`

	// initial effective date
	InitialEffectiveDate string `json:"initialEffectiveDate,omitempty"`

	// is easy quote plan
	IsEasyQuotePlan bool `json:"isEasyQuotePlan,omitempty"`

	// issue age list
	IssueAgeList []*IssueAgeDTO `json:"issueAgeList"`

	// key
	Key string `json:"key,omitempty"`

	// max benefit elect status code
	MaxBenefitElectStatusCode string `json:"maxBenefitElectStatusCode,omitempty"`

	// member benefit option list
	MemberBenefitOptionList []*MemberBenefitOptionDTO `json:"memberBenefitOptionList"`

	// money type list
	MoneyTypeList []*MoneyTypeDTO `json:"moneyTypeList"`

	// multiple option
	MultipleOption string `json:"multipleOption,omitempty"`

	// narl key
	NarlKey string `json:"narlKey,omitempty"`

	// overridden
	Overridden bool `json:"overridden,omitempty"`

	// parent description
	ParentDescription string `json:"parentDescription,omitempty"`

	// parent key
	ParentKey string `json:"parentKey,omitempty"`

	// pending amount
	PendingAmount string `json:"pendingAmount,omitempty"`

	// percent benefit
	PercentBenefit bool `json:"percentBenefit,omitempty"`

	// plan code
	PlanCode string `json:"planCode,omitempty"`

	// plan type
	PlanType string `json:"planType,omitempty"`

	// possible option choice list
	PossibleOptionChoiceList *OptionChoiceListDTO `json:"possibleOptionChoiceList,omitempty"`

	// premium amount
	PremiumAmount string `json:"premiumAmount,omitempty"`

	// premium detail list
	PremiumDetailList []*PremiumDetailDTO `json:"premiumDetailList"`

	// prepaid contract state
	PrepaidContractState string `json:"prepaidContractState,omitempty"`

	// product type
	ProductType string `json:"productType,omitempty"`

	// rate structure
	RateStructure string `json:"rateStructure,omitempty"`

	// risk rule
	RiskRule *RiskRuleDTO `json:"riskRule,omitempty"`

	// selection amount set
	// Unique: true
	SelectionAmountSet []string `json:"selectionAmountSet"`

	// series
	Series string `json:"series,omitempty"`

	// short name
	ShortName string `json:"shortName,omitempty"`

	// signature date
	SignatureDate string `json:"signatureDate,omitempty"`

	// sort value
	SortValue int32 `json:"sortValue,omitempty"`

	// spouse tobacco use indicator
	SpouseTobaccoUseIndicator string `json:"spouseTobaccoUseIndicator,omitempty"`

	// status code
	StatusCode string `json:"statusCode,omitempty"`

	// system benefit key
	SystemBenefitKey string `json:"systemBenefitKey,omitempty"`

	// tobacco use indicator
	TobaccoUseIndicator string `json:"tobaccoUseIndicator,omitempty"`

	// tpm percent benefit
	TpmPercentBenefit bool `json:"tpmPercentBenefit,omitempty"`

	// tranch detail effective date
	TranchDetailEffectiveDate string `json:"tranchDetailEffectiveDate,omitempty"`

	// transfer date
	TransferDate string `json:"transferDate,omitempty"`

	// transfer type
	TransferType string `json:"transferType,omitempty"`

	// units
	Units string `json:"units,omitempty"`
}

// Validate validates this benefit d t o req
func (m *BenefitDTOReq) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBenefitFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBenefitTranchList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoverageGrouping(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEligibilityRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueAgeList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemberBenefitOptionList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMoneyTypeList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePossibleOptionChoiceList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePremiumDetailList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelectionAmountSet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BenefitDTOReq) validateBenefitFeature(formats strfmt.Registry) error {
	if swag.IsZero(m.BenefitFeature) { // not required
		return nil
	}

	if m.BenefitFeature != nil {
		if err := m.BenefitFeature.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("benefitFeature")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("benefitFeature")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) validateBenefitTranchList(formats strfmt.Registry) error {
	if swag.IsZero(m.BenefitTranchList) { // not required
		return nil
	}

	for i := 0; i < len(m.BenefitTranchList); i++ {
		if swag.IsZero(m.BenefitTranchList[i]) { // not required
			continue
		}

		if m.BenefitTranchList[i] != nil {
			if err := m.BenefitTranchList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("benefitTranchList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("benefitTranchList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) validateCoverageGrouping(formats strfmt.Registry) error {
	if swag.IsZero(m.CoverageGrouping) { // not required
		return nil
	}

	if m.CoverageGrouping != nil {
		if err := m.CoverageGrouping.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("coverageGrouping")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("coverageGrouping")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) validateEligibilityRule(formats strfmt.Registry) error {
	if swag.IsZero(m.EligibilityRule) { // not required
		return nil
	}

	if m.EligibilityRule != nil {
		if err := m.EligibilityRule.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("eligibilityRule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("eligibilityRule")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) validateIssueAgeList(formats strfmt.Registry) error {
	if swag.IsZero(m.IssueAgeList) { // not required
		return nil
	}

	for i := 0; i < len(m.IssueAgeList); i++ {
		if swag.IsZero(m.IssueAgeList[i]) { // not required
			continue
		}

		if m.IssueAgeList[i] != nil {
			if err := m.IssueAgeList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("issueAgeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("issueAgeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) validateMemberBenefitOptionList(formats strfmt.Registry) error {
	if swag.IsZero(m.MemberBenefitOptionList) { // not required
		return nil
	}

	for i := 0; i < len(m.MemberBenefitOptionList); i++ {
		if swag.IsZero(m.MemberBenefitOptionList[i]) { // not required
			continue
		}

		if m.MemberBenefitOptionList[i] != nil {
			if err := m.MemberBenefitOptionList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("memberBenefitOptionList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("memberBenefitOptionList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) validateMoneyTypeList(formats strfmt.Registry) error {
	if swag.IsZero(m.MoneyTypeList) { // not required
		return nil
	}

	for i := 0; i < len(m.MoneyTypeList); i++ {
		if swag.IsZero(m.MoneyTypeList[i]) { // not required
			continue
		}

		if m.MoneyTypeList[i] != nil {
			if err := m.MoneyTypeList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("moneyTypeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("moneyTypeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) validatePossibleOptionChoiceList(formats strfmt.Registry) error {
	if swag.IsZero(m.PossibleOptionChoiceList) { // not required
		return nil
	}

	if m.PossibleOptionChoiceList != nil {
		if err := m.PossibleOptionChoiceList.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("possibleOptionChoiceList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("possibleOptionChoiceList")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) validatePremiumDetailList(formats strfmt.Registry) error {
	if swag.IsZero(m.PremiumDetailList) { // not required
		return nil
	}

	for i := 0; i < len(m.PremiumDetailList); i++ {
		if swag.IsZero(m.PremiumDetailList[i]) { // not required
			continue
		}

		if m.PremiumDetailList[i] != nil {
			if err := m.PremiumDetailList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("premiumDetailList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("premiumDetailList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) validateRiskRule(formats strfmt.Registry) error {
	if swag.IsZero(m.RiskRule) { // not required
		return nil
	}

	if m.RiskRule != nil {
		if err := m.RiskRule.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("riskRule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("riskRule")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) validateSelectionAmountSet(formats strfmt.Registry) error {
	if swag.IsZero(m.SelectionAmountSet) { // not required
		return nil
	}

	if err := validate.UniqueItems("selectionAmountSet", "body", m.SelectionAmountSet); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this benefit d t o req based on the context it is used
func (m *BenefitDTOReq) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBenefitFeature(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBenefitTranchList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCoverageGrouping(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEligibilityRule(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIssueAgeList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemberBenefitOptionList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMoneyTypeList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePossibleOptionChoiceList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePremiumDetailList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRiskRule(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BenefitDTOReq) contextValidateBenefitFeature(ctx context.Context, formats strfmt.Registry) error {

	if m.BenefitFeature != nil {

		if swag.IsZero(m.BenefitFeature) { // not required
			return nil
		}

		if err := m.BenefitFeature.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("benefitFeature")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("benefitFeature")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) contextValidateBenefitTranchList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BenefitTranchList); i++ {

		if m.BenefitTranchList[i] != nil {

			if swag.IsZero(m.BenefitTranchList[i]) { // not required
				return nil
			}

			if err := m.BenefitTranchList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("benefitTranchList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("benefitTranchList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) contextValidateCoverageGrouping(ctx context.Context, formats strfmt.Registry) error {

	if m.CoverageGrouping != nil {

		if swag.IsZero(m.CoverageGrouping) { // not required
			return nil
		}

		if err := m.CoverageGrouping.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("coverageGrouping")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("coverageGrouping")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) contextValidateEligibilityRule(ctx context.Context, formats strfmt.Registry) error {

	if m.EligibilityRule != nil {

		if swag.IsZero(m.EligibilityRule) { // not required
			return nil
		}

		if err := m.EligibilityRule.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("eligibilityRule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("eligibilityRule")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) contextValidateIssueAgeList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IssueAgeList); i++ {

		if m.IssueAgeList[i] != nil {

			if swag.IsZero(m.IssueAgeList[i]) { // not required
				return nil
			}

			if err := m.IssueAgeList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("issueAgeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("issueAgeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) contextValidateMemberBenefitOptionList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MemberBenefitOptionList); i++ {

		if m.MemberBenefitOptionList[i] != nil {

			if swag.IsZero(m.MemberBenefitOptionList[i]) { // not required
				return nil
			}

			if err := m.MemberBenefitOptionList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("memberBenefitOptionList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("memberBenefitOptionList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) contextValidateMoneyTypeList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MoneyTypeList); i++ {

		if m.MoneyTypeList[i] != nil {

			if swag.IsZero(m.MoneyTypeList[i]) { // not required
				return nil
			}

			if err := m.MoneyTypeList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("moneyTypeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("moneyTypeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) contextValidatePossibleOptionChoiceList(ctx context.Context, formats strfmt.Registry) error {

	if m.PossibleOptionChoiceList != nil {

		if swag.IsZero(m.PossibleOptionChoiceList) { // not required
			return nil
		}

		if err := m.PossibleOptionChoiceList.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("possibleOptionChoiceList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("possibleOptionChoiceList")
			}
			return err
		}
	}

	return nil
}

func (m *BenefitDTOReq) contextValidatePremiumDetailList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PremiumDetailList); i++ {

		if m.PremiumDetailList[i] != nil {

			if swag.IsZero(m.PremiumDetailList[i]) { // not required
				return nil
			}

			if err := m.PremiumDetailList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("premiumDetailList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("premiumDetailList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BenefitDTOReq) contextValidateRiskRule(ctx context.Context, formats strfmt.Registry) error {

	if m.RiskRule != nil {

		if swag.IsZero(m.RiskRule) { // not required
			return nil
		}

		if err := m.RiskRule.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("riskRule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("riskRule")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BenefitDTOReq) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BenefitDTOReq) UnmarshalBinary(b []byte) error {
	var res BenefitDTOReq
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
