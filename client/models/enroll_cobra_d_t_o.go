// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// EnrollCobraDTO EnrollCobraDTO
//
// swagger:model EnrollCobraDTO
type EnrollCobraDTO struct {

	// benefits to add
	BenefitsToAdd []*BenefitDTOReq `json:"benefitsToAdd"`

	// benefits to remove
	BenefitsToRemove []*BenefitDTOReq `json:"benefitsToRemove"`

	// cobra member group interface Id
	CobraMemberGroupInterfaceID string `json:"cobraMemberGroupInterfaceId,omitempty"`

	// cobra member group key
	CobraMemberGroupKey string `json:"cobraMemberGroupKey,omitempty"`

	// department name
	DepartmentName string `json:"departmentName,omitempty"`

	// dependents to add
	DependentsToAdd []*DependentDTOReq `json:"dependentsToAdd"`

	// dependents to update
	DependentsToUpdate []*DependentDTOReq `json:"dependentsToUpdate"`

	// facility Id
	FacilityID string `json:"facilityId,omitempty"`

	// portability description
	PortabilityDescription string `json:"portabilityDescription,omitempty"`

	// reason code
	ReasonCode string `json:"reasonCode,omitempty"`
}

// Validate validates this enroll cobra d t o
func (m *EnrollCobraDTO) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBenefitsToAdd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBenefitsToRemove(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependentsToAdd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependentsToUpdate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnrollCobraDTO) validateBenefitsToAdd(formats strfmt.Registry) error {
	if swag.IsZero(m.BenefitsToAdd) { // not required
		return nil
	}

	for i := 0; i < len(m.BenefitsToAdd); i++ {
		if swag.IsZero(m.BenefitsToAdd[i]) { // not required
			continue
		}

		if m.BenefitsToAdd[i] != nil {
			if err := m.BenefitsToAdd[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("benefitsToAdd" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("benefitsToAdd" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnrollCobraDTO) validateBenefitsToRemove(formats strfmt.Registry) error {
	if swag.IsZero(m.BenefitsToRemove) { // not required
		return nil
	}

	for i := 0; i < len(m.BenefitsToRemove); i++ {
		if swag.IsZero(m.BenefitsToRemove[i]) { // not required
			continue
		}

		if m.BenefitsToRemove[i] != nil {
			if err := m.BenefitsToRemove[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("benefitsToRemove" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("benefitsToRemove" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnrollCobraDTO) validateDependentsToAdd(formats strfmt.Registry) error {
	if swag.IsZero(m.DependentsToAdd) { // not required
		return nil
	}

	for i := 0; i < len(m.DependentsToAdd); i++ {
		if swag.IsZero(m.DependentsToAdd[i]) { // not required
			continue
		}

		if m.DependentsToAdd[i] != nil {
			if err := m.DependentsToAdd[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependentsToAdd" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dependentsToAdd" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnrollCobraDTO) validateDependentsToUpdate(formats strfmt.Registry) error {
	if swag.IsZero(m.DependentsToUpdate) { // not required
		return nil
	}

	for i := 0; i < len(m.DependentsToUpdate); i++ {
		if swag.IsZero(m.DependentsToUpdate[i]) { // not required
			continue
		}

		if m.DependentsToUpdate[i] != nil {
			if err := m.DependentsToUpdate[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependentsToUpdate" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dependentsToUpdate" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this enroll cobra d t o based on the context it is used
func (m *EnrollCobraDTO) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBenefitsToAdd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBenefitsToRemove(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDependentsToAdd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDependentsToUpdate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EnrollCobraDTO) contextValidateBenefitsToAdd(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BenefitsToAdd); i++ {

		if m.BenefitsToAdd[i] != nil {

			if swag.IsZero(m.BenefitsToAdd[i]) { // not required
				return nil
			}

			if err := m.BenefitsToAdd[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("benefitsToAdd" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("benefitsToAdd" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnrollCobraDTO) contextValidateBenefitsToRemove(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BenefitsToRemove); i++ {

		if m.BenefitsToRemove[i] != nil {

			if swag.IsZero(m.BenefitsToRemove[i]) { // not required
				return nil
			}

			if err := m.BenefitsToRemove[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("benefitsToRemove" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("benefitsToRemove" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnrollCobraDTO) contextValidateDependentsToAdd(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DependentsToAdd); i++ {

		if m.DependentsToAdd[i] != nil {

			if swag.IsZero(m.DependentsToAdd[i]) { // not required
				return nil
			}

			if err := m.DependentsToAdd[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependentsToAdd" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dependentsToAdd" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EnrollCobraDTO) contextValidateDependentsToUpdate(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DependentsToUpdate); i++ {

		if m.DependentsToUpdate[i] != nil {

			if swag.IsZero(m.DependentsToUpdate[i]) { // not required
				return nil
			}

			if err := m.DependentsToUpdate[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependentsToUpdate" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dependentsToUpdate" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *EnrollCobraDTO) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EnrollCobraDTO) UnmarshalBinary(b []byte) error {
	var res EnrollCobraDTO
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
